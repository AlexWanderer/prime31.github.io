---
layout: post
title: "Modeling 2D Water with Springs"
date: 2014-11-28 17:16:05 -0800
comments: true
categories: [CSS3, Sass, Media Queries]
published: true
---


Water is one of those things in the world of game development that can range anywhere from incredibly simple to insanely complex. Your first attempt at making water might not be anything more than a transparent quad. Compare a solution like that with something like the water as seen in [Assassin's Creed IV: Black Flag](https://www.google.com/search?q=Assassin%27s+Creed+IV:+Black+Flag+water&tbm=isch) or [Bioshock](https://www.google.com/search?q=bioshock+water&tbm=isch) to get an idea of how far it can be taken.

<!-- more -->

Luckily, for this project, I only needed 2D water which makes things signficantly more simple and easy enough to explain with just one blog post. Even with something like 2D water there are lots of different ways to model it. For this particular project (which is for mobile and desktop) I chose to model the water with springs. This provides a fun looking water that is easy to configure at runtime keeping it performant on mobile and better looking on desktop. Before we get into any details lets have a look at what the water looks like for low end mobile devices.


<iframe src="//gfycat.com/ifr/HelpfulThickGopher" frameborder="0" scrolling="no" width="846" height="476" style="-webkit-backface-visibility: hidden;-webkit-transform: scale(1);" ></iframe>


The plan is to utilize our good friend from back in grade school: Hooke's Law. If we layout a series of springs all in a vertical direction we can use them to simulate the oscillating water surface that you see above. ![](/images/posts/water2d/verts.png) We will of course need a mesh to go along with our invisible springs so we will use the spring's position as our top vert. What we end up with is a line of verts each with a spring to simulate the water surface. With that in place, making the mesh is simple: we just stick a vert below each spring (off the bottom of the image on the left) and we break up each square into two triangles. To provide a visual when working in the editor I just used a BoxCollider2D. This also has the added benefit of giving us its Bounds property so we know exactly where the top, bottom, left and right verts will be. We will need it at runtime to detect stuff falling into the water as well.


I mentioned previously that this method of making water can easily scale from mobile to desktop. We do this by making the number of springs that we use configurable. A lower number isn't as pretty but it is a lot cheaper performance-wise. At runtime we create the Mesh in Awake and set the number of springs based on the device we are running on. Here are some screenshots from the editor with a gizmo draw at each spring position:


### 20 Springs, 40 Springs and 100 Springs
![](/images/posts/water2d/water20.png)
![](/images/posts/water2d/water40.png)
![](/images/posts/water2d/water100.png)


The WaterColumn struct below is what was used to keep things organized. It handles calculating a simplified Hooke's Law in it's update method and it also stores the index into the Mesh.vertices array where it is located since we will need to modify the verts each frame.


{% codeblock lang:csharp %}
struct WaterColumn
{
	public float currentHeight;
	public float baseHeight;
	public float velocity;
	public float xPosition;
	public int vertexIndex;

	public void update( float dampening, float tension )
	{
		var heightOffset = baseHeight - currentHeight;
		velocity += tension * heightOffset - velocity * dampening;
		currentHeight += velocity;
	}
}
{% endcodeblock %}


At this point we have a Mesh (with a handy BoxCollider2D in the editor to position and shape it) and our WaterColumn struct ready to go but nothing is happening yet. We need to implement an Update method and start applying some forces to the springs. There are different ways to get creative with this part so I'll just touch on this particular implementation. Right now the springs don't affect each other at all which would make the water look pretty silly if we applied a force to any of our springs. We need to take into account what our neighbor springs are doing. The way that was accomplished is see if the neighbor springs are above or below the current spring and if so apply a force in that direction based on how far it is from the current spring and a made up constant. Something like this (which shows only the spring to our right): `spring[i].velocity += konstant * ( spring[i].currentHeight - spring[i+1].currentHeight)`.


The final piece of the simulation is detecting when something falls in the water and applying an appropriate force. This is where our BoxCollider2D (which is set as a trigger) comes in handy. We use OnTriggerEnter2D to detect anything hitting the water then use it's velocity and mass to affect our springs. ![](/images/posts/water2d/splash.png) The easy way to do this is to just find the nearest spring and apply the force to that spring. We don't take the easy way out here though so we are going to do this the right way. What we will do is use the Bounds of the object that fell in the water to determine exactly which springs should be affected. Once we find all the springs we just divide the force by affected spring count to spread out the force and apply it to each spring by adding to it's velocity.


That's all there is to the simulation. There is still more we can do to make it look better though for sure. The first gif showed what the water looks like with minimal springs/verts and only simple vertex colors. That is the low-end version of the water. Adding a refraction shader would give it a pretty neat look. You could also apply a blur shader that moves around and varies itself over time. The gif below uses a displacement map with a GrabPass to give provide a bit of life to the water. Unfortunately, the low quality gif doesn't let you see the true beauty of the effect.


<iframe src="http://gfycat.com/ifr/FreshGroundedAmericanmarten" frameborder="0" scrolling="no" width="846" height="478" style="-webkit-backface-visibility: hidden;-webkit-transform: scale(1);" ></iframe>